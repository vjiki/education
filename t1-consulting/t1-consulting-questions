для чего нужен стринг пул? - чтобы не создавать новые сущности(он выступает в роли кэша)

		что будет напечатано
        Stream.of(6,5,1,2).peek(System.out::println).findFirst();  //6
        Stream.of(6,5,1,2).peek(System.out::println).sorted().findFirst().get(); //6512
        Stream.of(6,5,1,2).peek(System.out::println).count();    //ничего не будет
        Stream.of(6,5,1,2).peek(System.out::println).filter(x->x<2).count();  //6512


если есть неviolitile переменная, и violitile. мы пишем значение в неviolitile переменную перед записью в violitile,
будет ли ее значение прочитано актуальное - да, вайлотийность распространяется и на то, что было записано во все переменные до нее
violitil-ность гарантирует атомарность записей double-ов и long-oв

какие данные обязательно атомарно записываются в java - все примитивы (кроме double и long) и все ссылки записываются атомарно

переупорядочивание кода - что это?
код может переупорядочиваться в угоду производительности
1.может произойти при компиляции - (javac) 2.при исполнении jvm-ом

Я разрабатываю библиотеку и в коде у меня есть место, которое может выбросить RuntimeException.
его надо обработать или пробрасывать дальше? (пробрасывать дальше)

что выберу rest или soap
-их нельзя сравнивать(soap - это просто протокол)

Сервис пометила @Service  +  в классе Autowired саму исплементацию - не возникнут ли проблемы
да,т.к.бин это прокси(dynamic proxy, прокси расширяет интерфейс, а не имплементацию
и в контексте спринга окажется бин не того типа который ты ожидаешь) ошибка-не найден бин такого типа

что будет если в бин Синглтон заАвтоварить Прототайп, будет ли работать Прототайп
нет, прототайп залетевший в синглтон остается там жить как синглтон\
(но request session действуют иначе, они живут в рамках одного запроса,но мы будем получать новый бин при обращении к нему в синглоне)


В пределах одного класса Transactional метод вызвать из не Transactional непрокатит, но как сделать если хочется-
- Самостоятельная инъекция (Self-inject)

livelock java - это
parallel stream - задача разбивается на мелкие подзадачи, которые выполняются параллельно на разных ядрах процессора

