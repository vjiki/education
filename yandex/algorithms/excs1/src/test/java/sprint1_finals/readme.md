недостатком выбранного метода является - потребление пямяти для indexesOfZeros плюс код с частными случаями 
(при indexesOfZeros.size() == 1 и  countZeroes >= 2), их лучше всегда избегать.
Но вложенных циклов нет, и это главное.
есть другое решение (в лоб) - за 2 прохода (последовательных, не вложенных) - более прямолинейное
Алгоритм такой:
1) считываем в исходный массив housesLine данные о номерах домов (как у тебя).
2) выделяем массив с результатом distanceBetweenHousesArray (как у тебя).
3) поскольку у нас сказано что хотя бы один ноль встречается, предполагаем что начальные условия для счетчика (counter)
   расстояния до нуля == housesLine.length (расстояние до нуля слева) поскольку по условию 1 ноль но имеется.
4) проходим весь массив слева-направо, увеличивая на каждом шаге счетчик на единицу counter++ и
   записывая в массив с результатом (с расстояниями), а при встрече с нулем - обнуляем счетчик counter.
5) выставляем опять счетчик в длину исходного массива counter = housesLine.length и проходим еще раз весь массив,
   но в обратном порядке - от последнего к первому элементу исходного массива, при встрече с нулем - тоже обнуляя его,
   а при встрече другого значения - не просто записываем как п.4 а сравниваем с уже записанным на этапе п.4 и 
   выбирая минимальный из текущего и предыдущего пункта.
   тогда indexesOfZero будет не нужен, и не надо будет обходить частные случаи